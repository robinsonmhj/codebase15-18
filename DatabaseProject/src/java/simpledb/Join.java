package simpledb;

import java.util.*;

import simpledb.Predicate.Op;

/**
 * The Join operator implements the relational join operation.
 */
public class Join implements DbIterator {

    private static final long serialVersionUID = 1L;
    private JoinPredicate p;
    private DbIterator child1;
    private DbIterator child2;
    private List<Tuple> l= new ArrayList<Tuple>();
    private Iterator<Tuple> i;

    /**
     * Constructor. Accepts to children to join and the predicate to join them
     * on
     * 
     * @param p
     *            The predicate to use to join the children
     * @param child1
     *            Iterator for the left(outer) relation to join
     * @param child2
     *            Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
        this.p=p;
        this.child1=child1;
        this.child2=child2;
        try{
        	fetchNext();
        }catch(Exception e){
        	e.printStackTrace();
        }
        
       
    }

    public JoinPredicate getJoinPredicate() {
        return p;
    }

    /**
     * @return
     *       the field name of join field1. Should be quantified by
     *       alias or table name.
     * */
    public String getJoinField1Name() {
      return child1.getTupleDesc().getFieldName(p.getField1());
    }

    /**
     * @return
     *       the field name of join field2. Should be quantified by
     *       alias or table name.
     * */
    public String getJoinField2Name() {
    	return child2.getTupleDesc().getFieldName(p.getField2());
    }

    /**
     * @see simpledb.TupleDesc#merge(TupleDesc, TupleDesc) for possible
     *      implementation logic.
     */
    public TupleDesc getTupleDesc() {
      TupleDesc td1=child1.getTupleDesc();
      TupleDesc td2=child2.getTupleDesc();
      
      return TupleDesc.merge(td1, td2);
      
    }

   

    /**
     * Returns the next tuple generated by the join, or null if there are no
     * more tuples. Logically, this is the next tuple in r1 cross r2 that
     * satisfies the join predicate. There are many possible implementations;
     * the simplest is a nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of Join
     * are simply the concatenation of joining tuples from the left and right
     * relation. Therefore, if an equality predicate is used there will be two
     * copies of the join attribute in the results. (Removing such duplicate
     * columns can be done with an additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     * 
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    private void fetchNext() throws TransactionAbortedException, DbException {
    	
    		TupleDesc td= getTupleDesc();
        	//System.out.println("f1 is "+p.getField1()+",f2 is "+p.getField2()+",operation is "+p.getOperator().name());
    		child1.open();
    		child2.open();
    		int i1=p.getField1(),i2=p.getField2();
    		Map<Object,List<Tuple>> map1= new HashMap<Object,List<Tuple>>();
    		long start=System.currentTimeMillis();
    		if(p.getOperator().equals(Op.EQUALS)){
    			System.out.println(start+"===============================Hello, I am using special joins on equals===============");
    			while(child1.hasNext()){
    				Tuple t1=child1.next();
    				Object f1=t1.getField(i1);
    				List<Tuple> tmpL=map1.get(f1);
    				if(tmpL==null)
    					tmpL= new ArrayList<Tuple>();
    				tmpL.add(t1);
    				map1.put(f1,tmpL);
    			}
    				
    			while(child2.hasNext()){
    				Tuple t2=child2.next();
    				Object f2=t2.getField(i2);
    				if(map1.containsKey(f2)){
    					List<Tuple> tmpL=map1.get(f2);
    					for(Tuple t1:tmpL){
    						Tuple t= new Tuple(td);
                			int i=0;
                			Iterator<Field> ite1=t1.fields();
                			while(ite1.hasNext()){
                				t.setField(i, ite1.next());
                				i++;
                			}
                			Iterator<Field> ite2=t2.fields();
                			while(ite2.hasNext()){
                				t.setField(i, ite2.next());
                				i++;
                			}
                			l.add(t);
    					}
    				}
    			}
    		}else{
    			
    			System.out.println(start+"===============================Hello, I am using regular joins on equals===============");
    			   while(child1.hasNext()){
    	            	Tuple t1=child1.next();
    	            	child2.rewind();
    	            	while(child2.hasNext()){
    	            		Tuple t2=child2.next();
    	            		//System.out.println("====original========t1="+t1+",t2="+t2);
    	            		if(p.filter(t1, t2)){
    	            			//System.out.println("====matched========t1="+t1+",t2="+t2);
    	            			Tuple t= new Tuple(td);
    	            			int i=0;
    	            			Iterator<Field> ite1=t1.fields();
    	            			while(ite1.hasNext()){
    	            				t.setField(i, ite1.next());
    	            				i++;
    	            			}
    	            			Iterator<Field> ite2=t2.fields();
    	            			while(ite2.hasNext()){
    	            				t.setField(i, ite2.next());
    	            				i++;
    	            			}
    	            			l.add(t);
    	            		}
    	            	}
    	            }
    		}
    		
    		
    		
         
        	
            child1.close();
        	child2.close();
        	long end=System.currentTimeMillis();
        	System.out.println(end+"===============================Hello, I am leaving the join===============using time "+(end-start)/1000.00+ " seconds");
    	
    	
    }
    
    
    public void open() throws DbException, TransactionAbortedException{
       i=l.iterator();
    }

    public boolean hasNext() throws TransactionAbortedException, DbException{
        return i.hasNext();
    }

    public Tuple next() throws NoSuchElementException,TransactionAbortedException, DbException{
        return i.next();
    }

    public void rewind() throws NoSuchElementException,TransactionAbortedException, DbException{
        close();
        open();
    }

 
    public void close() {
        i=null;
    }


}
